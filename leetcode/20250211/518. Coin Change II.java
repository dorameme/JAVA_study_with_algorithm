```java
/*
start:13:17
end:13:49
시간복잡도:O(n * m)  (n: amount, m: 동전 개수)
공간복잡도:O(n)  (배열 dp에 의해 amount 크기의 공간 필요)
풀이:
동전을 여러 번 사용할 수 있는 경우: 정방향 순회 가능
동전을 한 번만 사용할 수 있는 경우: 역방향 순회 필요
따라서, 현재 문제(change(int amount, int[] coins))에서는 순방향 순회로 바꾸어도 동일한 결과가 나온다.

주의할 점 = 왜 동전을 바깥 루프에 둬야 할까?
(1) 동전별로 순차적으로 경우의 수를 계산하여 중복 방지
각 동전을 한 번만 추가하는 방식으로 진행
동전 {1, 2, 5}를 순차적으로 고려하여 dp[i]를 업데이트
(2) 중복된 순서의 경우가 발생하지 않음
예를 들어 {1, 2}와 {2, 1}은 같은 경우이므로 한 번만 세야 함
위 방식대로 진행하면 {1, 2}로 만드는 경우가 업데이트될 때, 이미 {1}을 이용한 경우만 고려되므로 중복이 생기지 않음

그냥 쉽게말해서 특정동전에 대해서 한번 쫙 돌리고 그 다음 동전에 대해 연산을 이어서 해야함 -> 중복이 생길수없지.. !
*/

class Solution {
    public int change(int amount, int[] coins) {
        // 동전으로 만들 수 있는 경우의 수를 저장할 DP 배열
        int[] dp = new int[amount + 1];
        dp[0] = 1; // 금액 0을 만들 수 있는 경우는 아무 동전도 사용하지 않는 1가지 경우뿐이다.

        
        for (int j = coins.length - 1; j >= 0; j--) { 
            for (int i = 1; i <= amount; i++) {
                if (i >= coins[j]) // 현재 동전으로 금액 i를 만들 수 있는 경우
                    dp[i] += dp[i - coins[j]]; // 현재 동전을 포함한 경우의 수 추가
            }
        }

        return dp[amount]; // 최종적으로 amount를 만들 수 있는 방법의 수 반환
    }
}
```
